{"version":3,"file":"token.service-RvrPTISp.js","sources":["src/services/http.service.ts","src/services/token.service.ts"],"sourcesContent":["// ============================================\n// HTTP SERVICE - Base HTTP Client\n// Fixed Service Flow Web Component\n// ============================================\n\nimport { flowState } from '../store/flow.store';\n\n// ------------------------------------------\n// TYPES\n// ------------------------------------------\n\nexport interface HttpRequestConfig {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  endpoint: string;\n  body?: unknown;\n  headers?: Record<string, string>;\n  timeout?: number;\n  isFormData?: boolean;\n}\n\nexport interface HttpResponse<T = unknown> {\n  data: T;\n  status: number;\n  ok: boolean;\n}\n\nexport class HttpError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n    public response?: unknown,\n  ) {\n    super(message);\n    this.name = 'HttpError';\n  }\n}\n\n// ------------------------------------------\n// HTTP SERVICE CLASS\n// ------------------------------------------\n\nexport class HttpService {\n  private baseUrl: string = '';\n  private defaultTimeout: number = 60000; // 60 seconds\n\n  // ------------------------------------------\n  // CONFIGURATION\n  // ------------------------------------------\n\n  setBaseUrl(url: string): void {\n    // Remove trailing slash\n    this.baseUrl = url.replace(/\\/$/, '');\n  }\n\n  getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  setTimeout(timeout: number): void {\n    this.defaultTimeout = timeout;\n  }\n\n  // ------------------------------------------\n  // HEADERS\n  // ------------------------------------------\n\n  private getHeaders(customHeaders?: Record<string, string>, isFormData?: boolean): Headers {\n    const headers = new Headers();\n\n    // Don't set Content-Type for FormData (browser sets it with boundary)\n    if (!isFormData) {\n      headers.set('Content-Type', 'application/json');\n    }\n\n    // Add authentication headers if token exists\n    const token = flowState.token || sessionStorage.getItem('token');\n    const correlationId = flowState.correlationId || sessionStorage.getItem('correlationId');\n\n    if (token) {\n      headers.set('Authorization', `Bearer ${token}`);\n    }\n\n    if (correlationId) {\n      headers.set('X-Correlation-ID', correlationId);\n    }\n\n    // Add app headers\n    headers.set('App', 'shop');\n    headers.set('Platform', 'web');\n\n    // Add custom headers\n    if (customHeaders) {\n      Object.entries(customHeaders).forEach(([key, value]) => {\n        headers.set(key, value);\n      });\n    }\n\n    return headers;\n  }\n\n  // ------------------------------------------\n  // REQUEST METHOD\n  // ------------------------------------------\n\n  async request<T>(config: HttpRequestConfig): Promise<HttpResponse<T>> {\n    const { method, endpoint, body, headers: customHeaders, timeout, isFormData } = config;\n\n    // Ensure proper URL construction with slash between baseUrl and endpoint\n    const normalizedEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;\n    const url = `${this.baseUrl}${normalizedEndpoint}`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout || this.defaultTimeout);\n\n    try {\n      const fetchConfig: RequestInit = {\n        method,\n        headers: this.getHeaders(customHeaders, isFormData),\n        signal: controller.signal,\n      };\n\n      // Add body for non-GET requests\n      if (body && method !== 'GET') {\n        if (isFormData && body instanceof FormData) {\n          fetchConfig.body = body;\n        } else {\n          fetchConfig.body = JSON.stringify(body);\n        }\n      }\n\n      const response = await fetch(url, fetchConfig);\n      clearTimeout(timeoutId);\n\n      // Parse response\n      let data: T;\n      const contentType = response.headers.get('content-type');\n\n      // Get raw text first to handle all cases\n      // (some servers like Claro's API return text/plain for JSON responses)\n      const rawText = await response.text();\n\n      // Try to parse as JSON regardless of content-type\n      if (rawText && (rawText.startsWith('{') || rawText.startsWith('['))) {\n        try {\n          data = JSON.parse(rawText);\n        } catch {\n          // Not valid JSON, use as text\n          data = rawText as unknown as T;\n        }\n      } else if (contentType && contentType.includes('application/json')) {\n        try {\n          data = JSON.parse(rawText);\n        } catch {\n          data = rawText as unknown as T;\n        }\n      } else {\n        data = rawText as unknown as T;\n      }\n\n      // Handle HTTP errors\n      if (!response.ok) {\n        throw new HttpError(\n          `HTTP Error: ${response.status} ${response.statusText}`,\n          response.status,\n          data,\n        );\n      }\n\n      return {\n        data,\n        status: response.status,\n        ok: response.ok,\n      };\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof HttpError) {\n        throw error;\n      }\n\n      if (error.name === 'AbortError') {\n        throw new HttpError('Request timeout', 408);\n      }\n\n      throw new HttpError(error.message || 'Network error', 0);\n    }\n  }\n\n  // ------------------------------------------\n  // CONVENIENCE METHODS\n  // ------------------------------------------\n\n  async get<T>(endpoint: string, headers?: Record<string, string>): Promise<T> {\n    const response = await this.request<T>({\n      method: 'GET',\n      endpoint,\n      headers,\n    });\n    return response.data;\n  }\n\n  async post<T>(endpoint: string, body?: unknown, headers?: Record<string, string>): Promise<T> {\n    const response = await this.request<T>({\n      method: 'POST',\n      endpoint,\n      body,\n      headers,\n    });\n    return response.data;\n  }\n\n  async postFormData<T>(endpoint: string, formData: FormData, headers?: Record<string, string>): Promise<T> {\n    const response = await this.request<T>({\n      method: 'POST',\n      endpoint,\n      body: formData,\n      headers,\n      isFormData: true,\n    });\n    return response.data;\n  }\n\n  async put<T>(endpoint: string, body?: unknown, headers?: Record<string, string>): Promise<T> {\n    const response = await this.request<T>({\n      method: 'PUT',\n      endpoint,\n      body,\n      headers,\n    });\n    return response.data;\n  }\n\n  async delete<T>(endpoint: string, headers?: Record<string, string>): Promise<T> {\n    const response = await this.request<T>({\n      method: 'DELETE',\n      endpoint,\n      headers,\n    });\n    return response.data;\n  }\n}\n\n// ------------------------------------------\n// SINGLETON EXPORT\n// ------------------------------------------\n\nexport const httpService = new HttpService();\nexport default httpService;\n","// ============================================\n// TOKEN SERVICE - Authentication Token Management\n// Fixed Service Flow Web Component\n// ============================================\n// CRITICAL: This service MUST be called before any other API calls\n// The token is required for all API operations and also serves as the cart token\n\nimport { httpService } from './http.service';\nimport { flowActions } from '../store/flow.store';\nimport { TokenResponse } from '../store/interfaces';\n\n// ------------------------------------------\n// TOKEN SERVICE CLASS\n// ------------------------------------------\n\nclass TokenService {\n  private isInitializing: boolean = false;\n  private initPromise: Promise<boolean> | null = null;\n\n  // ------------------------------------------\n  // GET TOKEN FROM API\n  // ------------------------------------------\n\n  /**\n   * Fetches a new token from the API\n   * Endpoint: POST api/Token/getToken\n   * Request: { \"agentName\": \"\" }\n   */\n  async fetchToken(): Promise<TokenResponse> {\n    const response = await httpService.post<TokenResponse>('api/Token/getToken', {\n      agentName: '',\n    });\n\n    if (response.hasError) {\n      throw new Error(response.message || 'Failed to obtain token');\n    }\n\n    return response;\n  }\n\n  // ------------------------------------------\n  // INITIALIZE TOKEN\n  // ------------------------------------------\n\n  /**\n   * Initializes the token - checks sessionStorage first, then fetches if needed\n   * This method should be called at the start of the flow\n   */\n  async initialize(): Promise<boolean> {\n    // If already initializing, return the existing promise\n    if (this.isInitializing && this.initPromise) {\n      return this.initPromise;\n    }\n\n    this.isInitializing = true;\n\n    this.initPromise = (async () => {\n      try {\n        // Check if token exists in sessionStorage\n        const stored = flowActions.getStoredToken();\n\n        if (stored.token && stored.correlationId) {\n          // Use existing token\n          flowActions.setToken(stored.token, stored.correlationId);\n          console.log('[TokenService] Using existing token from sessionStorage');\n          return true;\n        }\n\n        // Fetch new token\n        console.log('[TokenService] Fetching new token...');\n        const response = await this.fetchToken();\n\n        // Store token\n        flowActions.setToken(response.token, response.correlationId);\n        console.log('[TokenService] Token obtained and stored successfully');\n\n        return true;\n      } catch (error) {\n        console.error('[TokenService] Failed to initialize token:', error);\n        flowActions.setError('Error al obtener el token de autenticaci√≥n');\n        return false;\n      } finally {\n        this.isInitializing = false;\n      }\n    })();\n\n    return this.initPromise;\n  }\n\n  // ------------------------------------------\n  // HELPER METHODS\n  // ------------------------------------------\n\n  /**\n   * Checks if a valid token exists\n   */\n  hasToken(): boolean {\n    return flowActions.hasToken();\n  }\n\n  /**\n   * Gets the current token\n   */\n  getToken(): string | null {\n    const stored = flowActions.getStoredToken();\n    return stored.token;\n  }\n\n  /**\n   * Gets the current correlation ID\n   */\n  getCorrelationId(): string | null {\n    const stored = flowActions.getStoredToken();\n    return stored.correlationId;\n  }\n\n  /**\n   * Clears the token (logout)\n   */\n  clearToken(): void {\n    flowActions.clearToken();\n    console.log('[TokenService] Token cleared');\n  }\n\n  /**\n   * Forces a new token fetch (refresh)\n   */\n  async refreshToken(): Promise<boolean> {\n    this.clearToken();\n    return this.initialize();\n  }\n\n  // ------------------------------------------\n  // GUARD METHOD\n  // ------------------------------------------\n\n  /**\n   * Ensures a token exists before proceeding\n   * Use this as a guard before API calls\n   */\n  async ensureToken(): Promise<void> {\n    if (!this.hasToken()) {\n      const success = await this.initialize();\n      if (!success) {\n        throw new Error('Failed to obtain authentication token');\n      }\n    }\n  }\n}\n\n// ------------------------------------------\n// SINGLETON EXPORT\n// ------------------------------------------\n\nexport const tokenService = new TokenService();\nexport default tokenService;\n"],"names":["flowState"],"mappings":"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"}
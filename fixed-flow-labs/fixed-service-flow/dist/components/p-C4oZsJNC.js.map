{"file":"p-C4oZsJNC.js","mappings":"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","names":[],"sources":["src/services/plans.service.ts"],"sourcesContent":["// ============================================\n// PLANS SERVICE - Internet Plans Management\n// Fixed Service Flow Web Component\n// ============================================\n\nimport { httpService } from './http.service';\nimport { tokenService } from './token.service';\nimport { PlansResponse, Plan, ApiResponse } from '../store/interfaces';\n\n// ------------------------------------------\n// INTERFACES\n// ------------------------------------------\n\ninterface AddToCartResponse extends ApiResponse {\n  code?: number; // cartId returned from backend\n}\n\ninterface CartItem {\n  token: string;\n  productId: number;\n  notificationDetailID: number;\n  chvSource: string;\n  promoCode: string;\n  installments: number;\n  decPrice: number;\n  decDeposit: number;\n  decDownPayment: number;\n  decTotalPrice: number;\n  Qty: number;\n  flowId: number;\n  ssoToken: string;\n  userID: string;\n  parentProductId: number;\n  parentCartId: number;\n  creditClass: string;\n  downgradeAllowed: boolean;\n  pendingAccelerated: number;\n  acceletartedAmount: number;\n  pastDueAmount: number;\n  delicuency: boolean;\n}\n\n// ------------------------------------------\n// PLANS SERVICE CLASS\n// ------------------------------------------\n\nclass PlansService {\n  // Track current plan in cart\n  private currentCartId: number = 0;\n\n  // ------------------------------------------\n  // GET PLANS\n  // ------------------------------------------\n\n  /**\n   * Fetches available internet plans for a service type\n   * Endpoint: POST api/Plans/getPlansInternet\n   *\n   * For CLARO HOGAR, the type should be \"internet\" (following TEL pattern)\n   */\n  async getPlans(serviceType: string, catalogId: number = 0): Promise<Plan[]> {\n    // Ensure token exists before making the call\n    await tokenService.ensureToken();\n\n    // Map service type to API type parameter\n    // TEL uses 'internet' for CLARO HOGAR products\n    let apiType = serviceType;\n    if (serviceType === 'CLARO HOGAR') {\n      apiType = 'internet';\n    }\n\n    console.log('[PlansService] Fetching plans for type:', apiType, 'catalogId:', catalogId);\n\n    const response = await httpService.post<PlansResponse>('api/Plans/getPlansInternet', {\n      catalogID: catalogId,\n      type: apiType,\n    });\n\n    console.log('[PlansService] Response:', response);\n\n    if (response.hasError) {\n      console.error('[PlansService] API error:', response.message);\n      throw new Error(response.message || 'Failed to fetch plans');\n    }\n\n    console.log('[PlansService] Plans found:', response.planList?.length || 0);\n    return response.planList || [];\n  }\n\n  // ------------------------------------------\n  // ADD TO CART (Main method - like TEL's api/Card/addToCart)\n  // ------------------------------------------\n\n  /**\n   * Adds a plan to the cart\n   * This replicates TEL's Card.pushAddToCart + Card.addToCart flow\n   * Endpoint: POST api/Card/addToCart\n   */\n  async addToCart(\n    plan: Plan,\n    parentCartId: number = 0,\n    parentProductId: number = 0,\n    installments: number = 0,\n    creditClass: string = ''\n  ): Promise<AddToCartResponse> {\n    // Ensure token exists before making the call\n    await tokenService.ensureToken();\n\n    const token = tokenService.getToken() || '';\n    const price = this.getEffectivePrice(plan);\n\n    // Build cart item following TEL's pushAddToCart structure\n    const cartItem: CartItem = {\n      token: token,\n      productId: plan.planId,\n      notificationDetailID: 0,\n      chvSource: '',\n      promoCode: sessionStorage.getItem('discountCoupon') || '',\n      installments: installments,\n      decPrice: price,\n      decDeposit: 0,\n      decDownPayment: 0,\n      decTotalPrice: price,\n      Qty: 1,\n      flowId: 1,\n      ssoToken: '',\n      userID: '0',\n      parentProductId: parentProductId,\n      parentCartId: parentCartId,\n      creditClass: creditClass,\n      downgradeAllowed: false,\n      pendingAccelerated: 0,\n      acceletartedAmount: 0,\n      pastDueAmount: 0,\n      delicuency: false,\n    };\n\n    // POST to api/Card/addToCart with cartItems as JSON string array\n    const response = await httpService.post<AddToCartResponse>('api/Card/addToCart', {\n      cartItems: JSON.stringify([cartItem]),\n    });\n\n    if (response.hasError) {\n      throw new Error(response.message || 'Failed to add plan to cart');\n    }\n\n    // Store cart info for later operations\n    if (response.code) {\n      this.currentCartId = response.code;\n    }\n\n    // Also store in sessionStorage (TEL pattern)\n    this.storePlanInSession(plan);\n\n    return response;\n  }\n\n  // ------------------------------------------\n  // ADD TO CART CURRENT PLAN (Keep existing plan)\n  // ------------------------------------------\n\n  /**\n   * Keeps the current plan in cart (used when continuing with existing plan)\n   * Endpoint: POST api/Plans/addToCartCurrentPlan\n   */\n  async addToCartCurrentPlan(productId: number, cartId: number): Promise<ApiResponse> {\n    // Ensure token exists before making the call\n    await tokenService.ensureToken();\n\n    const formData = new FormData();\n    formData.append('productId', String(productId));\n    formData.append('cartId', String(cartId));\n\n    return await httpService.postFormData<ApiResponse>('api/Plans/addToCartCurrentPlan', formData);\n  }\n\n  // ------------------------------------------\n  // DELETE PLAN FROM CART\n  // ------------------------------------------\n\n  /**\n   * Removes a plan from the cart\n   * Endpoint: POST api/Card/deleteItem\n   */\n  async deleteFromCart(cartId: number, productId: number = 0): Promise<ApiResponse> {\n    await tokenService.ensureToken();\n\n    const response = await httpService.post<ApiResponse>('api/Card/deleteItem', {\n      cartId: cartId,\n      productId: productId,\n    });\n\n    if (!response.hasError) {\n      // Clear local tracking if we deleted the current plan\n      if (cartId === this.currentCartId) {\n        this.currentCartId = 0;\n      }\n    }\n\n    return response;\n  }\n\n  // ------------------------------------------\n  // SESSION STORAGE (TEL Pattern)\n  // ------------------------------------------\n\n  /**\n   * Stores plan data in sessionStorage following TEL's pattern\n   */\n  private storePlanInSession(plan: Plan): void {\n    try {\n      // Store full plan object\n      sessionStorage.setItem('plan', JSON.stringify(plan));\n      // Store plan ID\n      sessionStorage.setItem('planId', String(plan.planId));\n      // Store price\n      const price = this.getEffectivePrice(plan);\n      sessionStorage.setItem('planPrice', String(price));\n      // Store plan code in Base64 (TEL pattern)\n      sessionStorage.setItem('planCodeInternet', btoa(plan.planSoc || String(plan.planId)));\n    } catch (e) {\n      console.error('[PlansService] Error storing plan in session:', e);\n    }\n  }\n\n  /**\n   * Gets stored plan from sessionStorage\n   */\n  getStoredPlan(): Plan | null {\n    try {\n      const planData = sessionStorage.getItem('plan');\n      return planData ? JSON.parse(planData) : null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Gets stored plan ID from sessionStorage\n   */\n  getStoredPlanId(): number {\n    const planId = sessionStorage.getItem('planId');\n    return planId ? parseInt(planId, 10) : 0;\n  }\n\n  /**\n   * Gets current cart ID\n   */\n  getCartId(): number {\n    return this.currentCartId;\n  }\n\n  /**\n   * Sets current cart ID (from parent flow)\n   */\n  setCartId(cartId: number): void {\n    this.currentCartId = cartId;\n  }\n\n  /**\n   * Clears plan from session and memory\n   */\n  clearPlan(): void {\n    this.currentCartId = 0;\n    sessionStorage.removeItem('plan');\n    sessionStorage.removeItem('planId');\n    sessionStorage.removeItem('planPrice');\n    sessionStorage.removeItem('planCodeInternet');\n  }\n\n  // ------------------------------------------\n  // HELPER METHODS\n  // ------------------------------------------\n\n  /**\n   * Formats price for display\n   */\n  formatPrice(price: number): string {\n    return `$${price.toFixed(2)}`;\n  }\n\n  /**\n   * Parses plan description HTML to extract features\n   */\n  parsePlanFeatures(description: string): string[] {\n    if (!description) return [];\n\n    // Extract text from <li> tags\n    const liRegex = /<li[^>]*>([^<]+)<\\/li>/gi;\n    const features: string[] = [];\n    let match;\n\n    while ((match = liRegex.exec(description)) !== null) {\n      features.push(match[1].trim());\n    }\n\n    return features;\n  }\n\n  /**\n   * Gets the discount percentage if there's a sale price\n   */\n  getDiscountPercentage(originalPrice: number, salePrice: number): number {\n    if (!salePrice || salePrice >= originalPrice) return 0;\n    return Math.round(((originalPrice - salePrice) / originalPrice) * 100);\n  }\n\n  /**\n   * Checks if plan has a promotion\n   */\n  hasPromotion(plan: Plan): boolean {\n    return plan.bitPromotion || (plan.decSalePrice && plan.decSalePrice < plan.decPrice);\n  }\n\n  /**\n   * Gets the effective price (sale price if available, otherwise regular price)\n   */\n  getEffectivePrice(plan: Plan): number {\n    if (plan.decSalePrice && plan.decSalePrice < plan.decPrice) {\n      return plan.decSalePrice;\n    }\n    return plan.decPrice;\n  }\n\n  /**\n   * Sorts plans by price (ascending)\n   */\n  sortByPrice(plans: Plan[], ascending: boolean = true): Plan[] {\n    return [...plans].sort((a, b) => {\n      const priceA = this.getEffectivePrice(a);\n      const priceB = this.getEffectivePrice(b);\n      return ascending ? priceA - priceB : priceB - priceA;\n    });\n  }\n}\n\n// ------------------------------------------\n// SINGLETON EXPORT\n// ------------------------------------------\n\nexport const plansService = new PlansService();\nexport default plansService;\n"],"version":3}